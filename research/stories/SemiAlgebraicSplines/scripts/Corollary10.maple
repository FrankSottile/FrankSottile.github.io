#Corollary10.maple
#
#    This computes the multiplicity of the scheme S/I, where I is minimally generated by
# t forms of degree n lying in a pencil, each raised to the power r+1.  This is used
# in (currently) Corollary 10.  It also computes the Hilbert function in this case,
# for different values of t, n, and r (currently t=3, n=2, and r=1..11).
#
#################################################################################
#interface(quiet=true):
#
#  Hilbert function of S = R[x,y,z]
#
HPS := d -> (d+2)*(d+1)/2:
#
#  Let J = ideal G_1^{r+1}, ..., G_t^{r+1}, 
#
#  Where G_i has degree n in x,y,z, each pair is relaatively prime and they are members of
# a pencil, and these powers are linearly independent so that (t<=r+2, at least)
#
#  Using the Schenck-Stillman Hilbert-Burch resolution of R[x,y]/I, for I an ideal of powers of linear forms,
# pushing forward to $S$ and extending scalars to S gives the resolution of S/J.
#
#  S((-r-1-a)n)^{s_1} \oplus S((-r-2-a)n)^{s_2}  --> S((-r-1)n)^t --> S --> S/I
#
# where we have:
#
#  a := \floor (r+1)/(t-1) 
#
# and
#
s1:=(t-1)*a+t-r-2:
s2:=(t-1)-s1:
#
#  Thus the Hilbert function of S/J is
#
Mult := s1*HPS(d-(r+1+a)*n)+s2*HPS(d-(r+2+a)*n) - t*HPS(d-(r+1)*n) + HPS(d):
#
simplify(Mult);
#
#  This has a simple form
#
BNC:= x -> x*(x-1)/2;
#
simplify(n^2*BNC(a+r+2) - t*n^2*BNC(a+1));
#
expand(n^2*BNC(a+r+2) - t*n^2*BNC(a+1)-Mult);
#
#  Now let us compute the Hilbert function, and compare it to the constant Splines (CS)
#
HFS:= d ->  piecewise(d<0, 0, d>=0, HPS(d)):
#
#  This is for t=3.
#
interface(quiet=true):
printf("  r |  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26\n");
printf(" ---+------------------------------------------------------------------------------------------------------------\n");
T:=3:
n:=2:
for r from 1 to 11 do 
 printf("%3d |",r);
 t := min(T,r+1):
 a := floor((r+1)/(t-1)):
 s1:=(t-1)*a+t-r-2:
 s2:=(t-1)-s1:
 HF := d -> printf("%3d ",s1*HFS(d-(r+1+a)*n)+s2*HFS(d-(r+2+a)*n) - t*HFS(d-(r+1)*n) + HFS(d)):
 seq(HF(d), d=0..26);
 printf("\n");
end do:
printf(" ---+-----------------------------------------------------------------------------------------------------------\n");
printf(" CS |"); seq( printf("%3d ",(d+1)*(d+2)/2), d=0..26); printf("\n");
printf(" ---+-----------------------------------------------------------------------------------------------------------\n");
printf("  r |  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26\n");

