#
#  Procedures for Frank's maple scripts for dual equivalence graphs for the 
#    Grassmannian-Bruhat order
#
#  Here is a short list of the different routines in this file.
#
# promote(x,i)        This returns x if x<i or x+1 if i<=x.
# testZeroII(a,b,c,d)      Tests of t_{a,b}t_{c,d} is a forbidden chain of length two
# testZeroIII(a,b,c,d,e,f) Tests for a forbidden chain of length three
# testEasyZero(C)          Tests a longer chain for forbidden chains of lengths 2 or 3
# makeChainStep(All,Recent)  This is a main subroutine iteratively making all possible chains
#                              using valid substitutions, but checking is a substitution leads
#                              to a forbidden chain (for then all these chains are invalid).
# testEquivZero(Ch)        Given a chain, makes all chains, and sees if one contains a
#                              forbidden subchain of length two or three.
# makeAllChains(Ch)      Makes all chains equivalent to the given chain Ch
# Compare(u,v)           Compares the lists u,v of integers to see if u<v Lexicographically
# First(S)               Returns the lexicographically least element of a set S of words.
# threeTerm(w)           Applies one of the three-term substitutions/relations, assuming that
#                          the input list w has length six and consists of four distinct symbols.
# wordPrint(ch)          Helps in printing the chain to a file
# computeEdges(Cl)       Given all chains Cl in a given interval computes all colored edges
#                          between them in the dual equivalence.
# Descents(w)            Computes descent set in a given word w
# makeDesSeq(Gr)         Given a graph Gr, returns a pair [DescentTable, DescFreq], where
#                  DescentTable is a table whose value at a descent set is the indices of the 
#                        vertices with that descent set.
#                  DescFreq is a set of pairs  { [descent set, frequency}
# lexNext(b,Freqs)      Gives the lexicographically next sequence between b and Freqs
# makeVector(descentSets)   Computes the frequency vector of descent sets in the list of pairs
#                                       descentSets
# getMinimalVertex(descentPointer)   Does what it says.  Needed to test for graph isomorphisms
# makeBalls(Graph,descentPointer,vertex)  Computes the neighbourhoods of the lexicographically
#                                         least vertex in a graph.  Needed for graph isomorphism
# isIsomorphic(Grt,test, Grn, new)  Tests is two graphs are isomorphic
# makeNeighbors(V, Edges, Gr, map)   Used in testing if two graphs are isomorphic
# makeNC(n)            Makes all noncrossing matchings (used for chains of length n with 2n letters)
# makeLong(n)          Permutes these to get all such long chains.
# lengthen(pflatFourChain)     Takes a flat 4-chain of even length and tries to add on to it
# makeFlatFourChains(Graph)  Makes all flat 4-chains in a given graph of length at least six.
#
#
#
###################################################
promote:= (x,i) -> piecewise( x<i, x, x>=i, x+1):
###################################################
testZeroII:=proc(a,b,c,d)
 # Tests if the pair (a,b) (c,d) is a forbidden chain of length two
 #
 if ((a<=c) and (c<b) and (b<=d)) or ((c<=a) and (a<d) and (d<=b)) then
   return(false)
 else
   return(true)
 end if:
end proc:
##########################################
testZeroIII:=proc(a,b,c,d,e,f)
#  Tests to see of this triple t_{a,b}t_{c,d}t_{d,e} is a forbidden chain of
#    length three, need only check that the support of three pairs has size three.
#
 if nops({a,b,c,d,e,f})=3 then 
   return(false):
  else
   return(true):
 end if:
end proc:
##########################################
testEasyZero := proc(C)
 #
 #  Scans a chain to see if it has two or three adjacent transpositions
 #    that are forbidden
 #
 local lgth, window:
 lgth:= nops(C)/2:
 if lgth=1 then return(true): end if:
 if lgth>1 then
  for window from 1 to lgth-1 do
    if not(testZeroII(C[2*window-1..2*window+2][])) then return(false): end if:
  end do:
 end if:
 if lgth>2 then
  for window from 1 to lgth-2 do
    if not(testZeroIII(C[2*window-1..2*window+4][])) then return(false): end if:
  end do:
 end if:
 return(true)
end proc:
#######################################################################
#
#    This iteratively makes all chains that are equivalent to a given 
# chain, also checking to see if there is an equivalence to zero.
#   It can be improved with better programming
#
makeChainStep := proc(All,Recent)
 local nAll,New, C, window, PC, new, A, B;
 nAll:=All:
 New:=[]:
 for C in Recent do 
  #
  #  There are two-term relations
  #
  for window from 1 to nops(C)/2-1 do
   if nops({C[2*window-1..2*window+2][]})=4 then
    #
    # Since C was not equivalent to zero, there is a commutation possible
    #
    PC:=C:
    PC[2*window-1]:=C[2*window+1]:
    PC[2*window]  :=C[2*window+2]:
    PC[2*window+1]:=C[2*window-1]:
    PC[2*window+2]:=C[2*window]:
    if not(testEasyZero(PC)) then 
      #printf("####  Got a Zero  %a \n",PC):
      return(false):
     else
      if not member( PC, nAll) then
      #printf("####  Got a new one by a commutation!  %a \n",PC):
        nAll := nAll union {PC}:
        New := [New[], PC]:
      end if:
    end if:
   end if:
  end do:
  #
  #  Then there are the three-term relations
  #
  for window from 1 to nops(C)/2-2 do 
   if  nops({C[2*window-1..2*window+4][]})=4 then
    new:=false:
    #
    #  There is a three-term relation possible. 
    #
    A:=threeTerm(C[2*window-1..2*window+4]):
    if type(A,boolean) then new:=A: else new:=true: end if:
    PC:=[C[1..2*window-2][], A[], C[2*window+5..nops(C)][]]:
    if new and not(testEasyZero(PC)) then
      #printf("####  Got a Zero  %a \n",PC):
      return(false):
    end if:
    if new and not member( PC, nAll) then
      #printf("####  Got a new one by a three term relation!  %a \n",PC):
        nAll := nAll union {PC}:
        New := [New[], PC]:
    end if:
   end if:
  end do:
 end do:
 return([nAll,New]):
end proc:
##############################################################################
testEquivZero := proc(Ch)
#
#  Out is a set
#
 local Out:
 Out:=makeAllChains(Ch):
 if type(Out, boolean) then
   return([false,[]]):
  else
   return([true,Out])
 end if:
end proc:
##############################################################################
makeAllChains := proc(Ch)
 #
 #    Given a chain Ch this routine computes the equivalence class of Ch,
 # while also testing to see if Ch is equivalent to zero.  It either returns
 # the Boolean "false" (Ch is null) or the equivalence class of Ch.
 #
 local All, Recent, Out:
 if not testEasyZero(Ch) then
   return(false):
  else
  All:={Ch};
  Recent:=[Ch];
  while Recent<>[] do
   Out:=makeChainStep(All,Recent):
   if type(Out, boolean) then
     return(false):
    else
     All:=Out[1]:
     Recent:=Out[2]:
   end if:
  end do:
  return(Out[1])
 end if:
end proc:
##############################################################################
Compare:=proc(u,v)
#
#  Given lists u, v, of integers u,v, this evaluates u<v lexicographically
#
 local i:
 if u=v then return(true): end if:
 for i from 1 to min(nops(u),nops(v)) do 
  if u[i]<v[i] then return(true): end if:
  if u[i]>v[i] then return(false): end if:
 end do:
 if nops(u)<nops(v) then return(true): end if:
 if nops(u)>nops(v) then return(false): end if:
end proc:
####################################################
First := proc(S)
#
#  This returns the lexicographically least element of S
#
 local first, w:
 first:=op(1,S):
 for w in S do 
  if (Compare(w,first)) then first:=w: end if:
 end do:
 return(first):  
end proc:
##############################################################
threeTerm := proc(w)
#
#    This routine applies the three-term relation.
# It assumes that w consists of three letters, so that it is
# a sequence of length six.
 local a,b,c,d,v:
 v := sort(convert(convert(w,set),list)):
 a:=v[1]: b:=v[2]: c:=v[3]: d:=v[4]:
 #
 #   Annoyingly, there are four cases, depending on how the letters are
 # arranged in w.   We write  v = [ a<b<c<d ]
 #
 if w=[b,c, c,d, a,c] then 
  return([b,d, a,b, b,c])
 end if:
 # 
 if w=[b,d, a,b, b,c] then 
  return([b,c, c,d, a,c])
 end if:
 # 
 if w=[a,c, c,d, b,c] then 
  return([b,c, a,b, b,d])
 end if:
 # 
 if w=[b,c, a,b, b,d] then 
  return([a,c, c,d, b,c])
 end if:
# lprint(w);
 return(false)
end proc:
##############################################################
wordPrint:=proc(ch)
#
#  Converts a chain (list of numbers) into a string list
#
 local ii,str:
 str:="[":
 for ii from 1 to nops(ch)-1 do
  str:=sprintf("%s%d,",str,ch[ii]):
 end do:
 return(sprintf("%s%d]",str,ch[nops(ch)])):
end proc:
###################################################
computeEdges := proc(Cl)
#
#  Cl is a list of all chains in a given interval (equivalence class)
#
#  This script computes the colored edges in Cl, including the fixed points
#
 local i,Edge,j,w,sw,Done,new_sw,lgth,ii,new_w,jj:
 global verbose:
 #
 for i from 2 to (nops(Cl[1])-4)/2+1 do 
  Edge[i]:={}:
  for j from 1 to nops(Cl) do 
   w:=Cl[j]:
   ##############################################################
   #  sw is the Short Word of three pairs on which edges coloured i can occur
#   sw:=w[2*i-1..2*i+4]:
   sw:=w[2*i-3..2*i+2]:  
   if verbose then lprint(sw); end if:
   #   This is a valid subword, so the entries in positions 2 and 4, 
   #      and in 4 and 6 are distinct.
    # It has a single descent at these two positions if and only if (sw[4]-sw[2])*(sw[4]-sw[6])>0
    if (sw[4]-sw[2])*(sw[4]-sw[6])>0 then
     Done:=false:
     # There is a descent and phi_i can be applied 
     # check for a type B edge
     if  ({sw[1],sw[2]} intersect {sw[3],sw[4]}) intersect {sw[5],sw[6]} <> {} then
      if verbose then printf("There is a type  B  relation possible\n"): end if:
      #   new_sw is the result of the relation
      new_sw:=threeTerm(sw):
      if verbose then printf("new_sw:=%a\n",new_sw): end if:
        Done:=true:
     end if:
     # 
     if verbose then lprint((sw[2]-sw[4])*(sw[2]-sw[6]), (sw[6]-sw[4])*(sw[6]-sw[2])); end if:
     if not(Done) and (sw[2]-sw[4])*(sw[2]-sw[6])<0  then
      # the first letter sw[2] of sw[2,4,6] has middle value
      if verbose then printf("Middle value is first, nops(sw)=%d\n",nops({sw[3..6][]})): end if:
      if nops({sw[3..6][]}) = 4 then
        # can apply type A commutation
        if verbose then printf("Type  A  relation on the last two letters\n"): end if:
        new_sw:=[sw[1],sw[2], sw[5],sw[6], sw[3],sw[4]]:
       else  
        # nops is 3 and can apply a type C commutation
        if verbose then printf("Type  C  relation moving first letter to the end\n"): end if:
        new_sw:=[sw[3],sw[4], sw[5],sw[6], sw[1],sw[2]]:
      end if:
     end if:
  
     if not(Done) and (sw[6]-sw[4])*(sw[6]-sw[2])<0  then
       # the middle value is in the last letter
       if verbose then printf("The middle value is in the last letter\n"): end if:
       if nops({sw[1..4][]}) = 4 then
        # can apply type A commutation
        if verbose then printf("Type  A  relation on the first two letters\n"): end if:
        new_sw:=[sw[3],sw[4], sw[1],sw[2], sw[5],sw[6]]:
       else  
        # nops is 3 and can apply a type C commutation
        if verbose then printf("Type  C  relation moves last letter to the beginning\n"): end if:
        new_sw:=[sw[5],sw[6], sw[1],sw[2], sw[3],sw[4]]:
      end if:
     end if:

    else  # This is a fixed point of phi_i

    if verbose then printf("This is a fixed point of phi_%d\n",i); end if:
    new_sw:=sw:

   end if:

   lgth:=nops(w):
   if i=2 then 
    new_w:=[new_sw[],seq(w[ii],ii=7..lgth)]:
    end if:
   if (i>2) and (2*i+2<lgth) then
    new_w:=[seq(w[ii],ii=1..2*i-4),new_sw[],seq(w[ii],ii=2*i+3..lgth)];
   end if:
   if (i>2) and (2*i+2=lgth) then
    new_w:=[seq(w[ii],ii=1..2*i-4),new_sw[]];
   end if:

   for jj from 1 to nops(Cl) do 
    if jj<>j and new_w=Cl[jj] then 
     # We have an edge of color i
     Edge[i]:=Edge[i] union {sort([jj,j])}:
    end if:
   end do:
   if verbose then printf("%d w=%a   new_w=%a\n",j,w,new_w); end if:

  end do:
 end do:
 return(eval(Edge))
end proc:
##############################################################
Descents:=proc(w)
#
#   This procedure computes the descents of a given word
#
 local i, Des,n:
 n:=nops(w)/2:
 Des:=[]:
 for i from 1 to n-1 do
  if w[2*i]>w[2*i+2] then Des:=[Des[],i]: end if:
 end do:
 return(Des)
end proc:
################################################################
makeDesSeq := proc(Gr)
#
#   This returns a pair [DescentTable, DescFreq], where
# DescentTable is a table whose value at a descent set is the indices of the 
#               vertices with that descent set.
# DescFreq is a set of pairs  { [descent set, frequency}
#
 local n, descents, desc, DescentTable, DescFreq, i:
 n:=nops(Gr[1][1])/2:
 descents:={}:
 table(DescentTable):
 for i from 1 to nops(Gr[1]) do 
  desc:=Descents(Gr[1][i]):
  if member(desc,descents) then 
    DescentTable[desc]:=[DescentTable[desc][],i]:
   else
    descents:=descents union {desc}:
    DescentTable[desc]:= [i]:
  end if:
 end do:
 DescFreq:={}:
 for desc in descents do
  DescFreq := DescFreq union {[desc, nops(DescentTable[desc])]}:
 end do:
 return([eval(DescentTable), DescFreq])
end proc:
######################################################
lexNext := proc(b,Freqs)
#
#  This returns the lexicographically next sequence a that is between 1...1 and Freqs
#
 local j, ii,a:
 if b=Freqs then return(false): end if:
 j:=nops(b):
 a:=eval(b):
 while a[j]=Freqs[j] do 
  j:=j-1:
 end do:
 a[j]:=a[j]+1:
 for ii from j+1 to nops(Freqs) do 
  a[ii]:=1: 
 end do:
 return(a)
end proc:
###########################################################
makeVector := proc(descentSets)
 global n, Partitions:
 local Vect, descSet, ind, Pair:

 Vect := Vector[row](2^(n-1), 0):
 ###########################################################
 for Pair in descentSets do 

  descSet := Pair[1]:
  ind := 1+sum( 2^(descSet[ii]-1), ii=1..nops(descSet)):
  Vect[ind] := Pair[2]:

 end do:
 ###########################################################
 return(Vect):
end proc:
###########################################################

################################################################
getMinimalVertex := proc(descentPointer)
 #
 # Returns a pair: the vertex of minimal frequency.
 #   This is used to initialize the vertex for makeBalls
 #
 global n:
 local minFreq, minDescent, Pr, minimums:
 #
 minFreq:=n:
 minimums:={}:
 for Pr in descentPointer[2] do
  if Pr[2]<minFreq then
    minFreq := Pr[2]:
    minimums := {Pr[1]}:
   elif Pr[2]=minFreq then
    minimums := minimums union {Pr[1]}:
  end if
 end do:
 minDescent:=First(minimums):

 return(op(1,descentPointer[1][minDescent])):
end proc:
################################################################
makeBalls := proc(Graph,descentPointer,vertex)
 #
 # Graph is a graph represented as a pair [ list_of_vertices, set_of_edges ]
 # descentPointer is a pair of pointers.   The first points a descent to the 
 #    vertices with that descent and the second points to the frequency of that descent,
 #    encoded as a set of pairs.
 # vertex is a particular vertex, represented by its index.
 #
 # We represent a graph as a sequence of shells of vertices and edges
 #   a given distance from a distinguished vertex, stored as a table, Ball[i].
 # Ball[i] is a triple:  [{vertices at distance i}, 
 #    {edges to distance i}, {edges among distance i} ]:
 #
 global n,k,verbose;
 local VertexIndices, AllEdges, Ball, rad, oldVertices, newVertices, 
       newEdges, betweenEdges, tempEdges, edge, ii:
 #
 # We build Ball iteratively.  We initialize the vertices and edges.
 #
 VertexIndices := {seq(ii,ii=1..k)}:
 AllEdges := eval(Graph[2]):
 #
 #  Now, we iteratively build the graph.  
 #
 Ball[0] := [{vertex}, {}, {}]:
 VertexIndices := VertexIndices minus {vertex}:
 rad:=0:
 while VertexIndices <> {} do
  oldVertices := Ball[rad][1];
  #
  #  Initialize graph at radius = rad + 1:
  #
  newVertices := {}:
  newEdges := {}:
  betweenEdges := {}:
  #
  # Find edges that meet the oldVertices, move them to newEdges and 
  #   remove them from AllEdges (copied as tempEdges).
  #    and edge is a triple [color, vertex_1, vertex_2]
  #
  tempEdges := eval(AllEdges):
  for edge in AllEdges do
   if member(edge[2], oldVertices) or member(edge[3], oldVertices) then 
    #
    #  This edge meets the ball of radius rad
    #
    newEdges := newEdges union {edge}:
    tempEdges := tempEdges minus {edge}:
    newVertices := newVertices union ( {edge[2],edge[3]} minus oldVertices ):
   end if:
  end do:
  VertexIndices := VertexIndices minus newVertices:
  AllEdges:=tempEdges:
  for edge in AllEdges do
   if  {edge[2],edge[3]} subset newVertices  then 
    #
    #  This edge is between two vertices at distance rad + 1
    #
    betweenEdges := betweenEdges union {edge}:
    tempEdges := tempEdges minus {edge}:
   end if:  
  end do: 
  AllEdges:=tempEdges:
  rad := rad + 1:
  Ball[rad] := [ newVertices, newEdges, betweenEdges ]:
  
 end do:

 return(eval(Ball))
end proc:
################################################################
isIsomorphic := proc(Grt, test, Grn, new)
#
# Tests to see if two graphs are isomorphic.  
#  The vertices are labeled by descent sets, (Gr[1]) and the graphs 
#  are encoded by their neighbourhoods of distinguished vertices 
#  (a distinguished vertex has lexicographically minimal descent set), 
#  It builds an isomorphism shell by shell, testing all the way.
#
 global n,k,verbose:
 local i, map, rad, diameter, Vtest, Vnew, Etest, Enew, Btest, Bnew, edge, 
      Vold, Vin, Vout, DescT, DescN, vertexIndex, ind, Tedge, BMatch, 
      type, edgeMatch, Nedge, VNout, VNin, removeEdge:
 #
 #  Deal with easy equal / not possibly isomorphic
 #
 if test=new then return(true): end if:
 if {indices(test)}<>{indices(new)} then 
  if verbose then 
    printf("The indices, %a, in test are different \n  from those, %a, in new\n",
          [indices(test)],[indices(new)]):
  end if:
  return(false): 
 end if:
 #
 #
 map := [seq(0,i=1..k)]:
 diameter := nops([indices(test)])-1:
 if verbose then printf(" test := %a\n new  := %a\n",test,new): end if:
 #
 #  map is a partial permutation that is trying to build up an isomorphism ?
 #
 map[op(test[0][1])]:=op(new[0][1]):
 if verbose then printf(" map = %a, from distinguished vertices %a %a \n",map,op(test[0][1]),op(new[0][1])): end if:
 for rad from 1 to diameter do
  #
  # V:= vertices   E:= edges  B:=between edges
  #
  Vtest:=test[rad][1];
  Vnew := new[rad][1]:
  Etest:=test[rad][2]:
  Enew := new[rad][2]:
  Btest:=test[rad][3]:
  Bnew := new[rad][3]:
  #
  #  First, an easy test to check that the numbers of V, E, and B are the same
  #
  if nops(Vtest)<>nops(Vnew) or nops(Etest)<>nops(Enew) or nops(Btest)<>nops(Bnew) then
    if verbose then  
       printf("Numbers of Vertices (%d,%d), Edges (%d,%d), or Between Edges (%d,%d) are different\n",Vtest,Vnew,Etest,Enew,Btest,Bnew);
    end if:
   return(false)
  end if:
  #
  # For vertices in test[rad-1][1] \simeq_map new[rad-1][1] at distance
  #  rad-1 from the distinguished vertex, we compute their neighbours in Vtest and Vnew.
  # This is encoded in a table DescV/N[v][i] and [i,j], where
  #  DescT/N[v][i]   is the descent set at the end of an edge of type i emanating
  #                  from the v-th vertex (or 0 if none), and  
  #  DescT/N[v][i,i+1] is 1 if there is a double i,i+1 edge and not defined if not. 
  #
  DescT := makeNeighbors(test[rad-1][1],Etest,Grt,map):  
  DescN := makeNeighbors( new[rad-1][1],Enew ,Grn,[seq(i,i=1..k)]):  
  if verbose then printf(" DescT := %a, DescN := %a\n", eval(DescT), eval(DescN)): end if:
  #
  # A simple boolean query for equality does not work, so I'll have to test these
  #   entry-by-entry.
  #
  # The indices should the same, as they are new[rad-1][1].
  #
  if not({indices(DescT)}={indices(DescN)}) then 
#   lprint(map);
#   lprint(eval(DescT));
#   lprint(eval(DescN));
#   lprint({indices(DescT)}, {indices(DescN)} );
   return("Something is not right");
  end if:
#  lprint({indices(DescT)}, test[rad-1][1], {indices(DescN)},new[rad-1][1]);
  #
  # Check that the indices in DescT/N[vertexIndex]) coincide
  #
  for vertexIndex in new[rad-1][1] do 
   if not({indices(DescT[vertexIndex])}={indices(DescN[vertexIndex])})  then
#    printf("indices different in DescT/N at vertex=%d\n", vertexIndex):
    return(false):
   end if:
   for ind in {indices(DescT[vertexIndex])} do 
    if DescT[vertexIndex][op(ind)]<>DescN[vertexIndex][op(ind)] then
#    lprint(ind, DescT[vertexIndex][op(ind)], DescN[vertexIndex][op(ind)]);
#    printf("endpoints of edges are different at vertex=%d\n", vertexIndex):
    return(false):
    end if:
   end do:
  end do:
  #
  #  Now, the edges emanating from test[rad-1][1] and new[rad-1][1] are the
  #   same in that the same color goes to the same descent set, and the 
  #   double edges are the same.  Now we try to match of the two sets in
  #   test[rad][1] and new[rad][1] using these edges.
  #
  #  Use edges in test to build up the map between vertex sets
  #
#printf("%a \n %a\n",Etest,Enew):
  for edge in Etest do
   Vold:=test[rad-1][1]:
   Vout := op( Vold intersect {edge[2],edge[3]} ): 
   Vin  := op( {edge[2],edge[3]} minus {Vout} ):
   type := edge[1]:
   edgeMatch:=false:
   for Nedge in Enew do
    if Nedge[1]=type then
     #
     # Types/colours of edges match !
     #
     VNout := op( new[rad-1][1] intersect {Nedge[2],Nedge[3]} ):
     if VNout=map[Vout] then
      #
      #  edge and Nedge are incident to corresponding vertices at  (rad-1)
      #     So, we extend the map (with a little test), flag the edge for 
      #     removal, and note that we found a match.
      #
      VNin := op( {Nedge[2],Nedge[3]} minus {VNout} ):
      if map[Vin]=0 then 
        map[Vin] := VNin:
       else
#printf("map = %a\n",map):
        if map[Vin]<>VNin then 
         printf("%a\n%a\n",test,new):
         return("Something is wrong with this graph!") 
        end if:
      end if:
      removeEdge:=Nedge:
      edgeMatch:=true:
     end if:
    end if:
   end do:
   #
   #  If no matching Edge, then the graphs are not isomorphic, otherwise
   #    remove the matching edge.
   #
#lprint(edgeMatch);
   if not(edgeMatch) then 
     return(false) 
    else
     Enew:=Enew minus {removeEdge}:
   end if:
  end do:
  #
  #  Now, test the between edges
  #
#printf("map = %a\n",map):
  for Tedge in Btest do 
   BMatch:=false:
   for Nedge in Bnew do 
    BMatch := BMatch or evalb(Tedge[1]=Nedge[1] and map[Tedge[2]]=Nedge[2]
                          and map[Tedge[3]]=Nedge[3]):
   end do:
   #
   if not(BMatch) then 
    printf("Between edges do not match: test=%a \n %26s new=%a\n",Tedge," ",Bnew):
    return(false):
   end if:
  end do:

 end do:
 return(true)
end proc:
######################################################################################
makeNeighbors := proc(V, Edges, Gr, map)
#
# This computes the enhanced degree sequence of the graph Gr restriced to Edges
#  emanating from Vo(ld). 
#  map is used to re-index the vertices.
#
# We compute the edges in Edges emanating from vertices in V, recording the 
#   color of the edge and descent set (stored in Gr[1]) of the other vertex
# This is encoded in a table Desc[v][i] and [i,j], where
#  Desc[v][i]   is the descent set at the end of an edge of type i emanating
#                  from the v-th vertex (or 0 if none), and  
#  Desc[v][i,j] is 1 if there is a double i,j edge and not defined if not. 
#
# We use the structural result that there is at most one edge of type i incident 
#  to any vertex.
#
 global n,k:
 local Desc, edge, v, ov, i:
 #
 # initialize Desc
 #
 for v in V do 
  for i from 2 to n-1 do 
   Desc[map[v]][i]:=0:
  end do:
 end do:
 #
 #  Fill Desc with the index of the other vertex
 #
 for edge in Edges do
  #
  # edge := [ color, one_vertex, other_vertex ]:
  #
  v  := op( V intersect {edge[2], edge[3]} ):
  ov := op( {edge[2], edge[3]} minus {v} ):
  #
  Desc[map[v]][edge[1]] := ov:
 end do:
 #
 # Record double edges with labels (i,i+1)
 #
 for v in V do   
  for i from 1 to n-3 do
   if  Desc[map[v]][i]=Desc[map[v]][i+1] and Desc[map[v]][i]<>0  then 
    Desc[map[v]][i,i+1]:=1:
   end if:
  end do:
 end do:
 #
 #  Now put in descent sets
 #
 for v in V do
  for i from 2 to n-1 do
   if  Desc[map[v]][i]<>0  then
    Desc[map[v]][i] := Gr[1][Desc[map[v]][i]]:
   end if:
  end do:
 end do:
 return(eval(Desc))
end proc:
##########################################################################
increment:= (x,inc) -> x+inc:
##########################################################################
makeNC := proc(n)
#
#  This procedure makes all noncrossing matchings, storing them as a list.
#
 local NC, nn, i, ch, och:
# 
 NC[0]:={[]}:
 for nn from 1 to n do 
  NC[nn]:={}:
  for i from 1 to nn do
   for ch in NC[i-1] do
    for och in NC[nn-i] do 
     NC[nn] := NC[nn] union { [1,2*i,map(increment,ch,1)[],map(increment,och,2*i)[]] }:
    end do:
   end do:
  end do:
 end do:
 return(NC[n])
end proc:
##########################################################################
makeLong := proc(n)
#
# This procedure returns a set of equivalence classes of words of length n
#  on the letters 1,...,2n.  Each equivalence class has size n!, as the 
#  elements of the monoid in each word fully commute; their (pairs of) indices
#  form a non-crossing matching of {1,...,2n}.
#
 local NC, ECs, ch, ec, perm, i;
#
 NC := makeNC(n):
 ECs:= {}:
 for ch in NC do 
  ec:={}:
  for perm in combinat[permute](n) do
   ec := ec union {[seq([ch[2*perm[i]-1],ch[2*perm[i]]][],i=1..n)]}:
  end do:
  ECs := ECs union {ec}:
 end do:
 return(ECs)
end proc:
#################################################################################
lengthen := proc(pflatFourChain)
 #
 # Procedure to add a 4-edge to a flat 3-chai, pflatFourChain.  
 # Returns a pair [boolean, partial_chain] 
 #  Boolean = false : cannot add to partial chain
 #  Boolean = true  : can add to partial chain and returns new chain
 #
  global admitTwoEdge, endPoints, Edges:
  local edge, myEdge, oddVertex, newEdge, newEvenVertex, threeEdge, continue, newVertex:
  #
  #  First check if there is a 3-edge at the current endpoint
  #    which is an even index and which must admit a 3-edge 
  #
  if not member( pflatFourChain[nops(pflatFourChain)], endPoints[3] ) then 
    if verbose then 
     lprint(pflatFourChain);
     printf("No 3-edge here! %d is not in the set admitting 3-edges:\n       %a \n", pflatFourChain[nops(pflatFourChain)], endPoints[3] );
    end if:
    return( [evalb(false),pflatFourChain] )
  end if:
  #
  #  Now find the 2-edge extending this
  # 
  for edge in Edges[2] do 
   if member( pflatFourChain[nops(pflatFourChain)], {edge[2],edge[3]} ) then 
    myEdge := edge:
   end if:
  end do:
  if verbose then 
    printf("Found an extending 2-edge : %a\n",myEdge);
  end if:
  #
  #  Does the other endpoint (oddVertex) of this 2-edge meet a 4-edge ? 
  #
  oddVertex:=op({myEdge[2],myEdge[3]} minus {pflatFourChain[nops(pflatFourChain)]}):
  if verbose then printf("Possible next odd vertex %a\n",oddVertex); end if:
  #
  # There are four possibilities, for this possible odd vertex to meet 4- and 3- edges
  #  The first two represent failures to extend the chain
  #
  if member( oddVertex, endPoints[3] intersect endPoints[4]) then
   if verbose then printf("oddVertex meets both 3- and 4- edge\n") end if:
   return([false, pflatFourChain]);
  end if:
  if not member( oddVertex, endPoints[3] union endPoints[4]) then
   if verbose then printf("oddVertex meets neither a 3- nor a 4- edge\n") end if:
   return([false, pflatFourChain]);
  end if:
  #
  #  At this point the odd vertex meets exactly one of a 3-edge or a 4-edge
  #
  #  If it meets just a 3-edge, possaibly we are at the start of a 2-3-2 connection
  #    in our chain.   See if this can be extended.
  #
  if member( oddVertex, endPoints[3]) then 
   if verbose then 
    printf("This possible odd Vertex meets a 3-edge, so "); 
    printf(" maybe we have a 2-3-2 chain here.\n"); 
   end if:
   #
   #  Find the 3-edge
   # 
   continue := evalb(false):
   for edge in Edges[3] do 
    if member(oddVertex, {edge[2],edge[3]}) then
     if verbose then
       printf("Found an extending 3-edge, %a, now need an extending 2-edge\n",edge);
     end if:
     continue:=true:
     newVertex := op({edge[2],edge[3]} minus {oddVertex}):
     threeEdge:=edge:
     break:
    end if:
   end do:
   if continue then
     for edge in Edges[2] do 
      if member(newVertex, {edge[2],edge[3]}) then
       if verbose then printf("Found an extending 2-edge, %a\n",edge); end if:
        oddVertex :=  op({edge[2],edge[3]} minus {newVertex}):
      end if:
     end do:
    else
     if verbose then printf("could not find a connecting 3-edge\n");  end if:
     return([false, pflatFourChain]);
   end if:
   #
   #
   #
  end if:
  #
  #  If we executed the previous conditional, we have a new oddVertex, and it is the 
  #    right endpoint of a 3-2-3-2 chain (so it does not have a 3-edge, but we should 
  #    check anyway).
  #
  if member( oddVertex, endPoints[4])  then
   #
   #  Make sure that this other endpoint does not meet a 3-edge.
   #
   if member( oddVertex, endPoints[3])   then 
     if verbose then printf("The new odd vertex has a 3-edge!\n"); end if:
     return( [evalb(false),pflatFourChain] ):
    else
     #
     #  Now find the edge and make sure that the new point is new
     #
     for newEdge in admitTwoEdge do
      if member( oddVertex, {newEdge[2],newEdge[3]}) then 
       if verbose then printf("Possibly found an extending four edge: %a\n",newEdge); end if:
       newEvenVertex := op({newEdge[2],newEdge[3]} minus {oddVertex}):
       if member( newEvenVertex, {pflatFourChain[]} ) then 
         if verbose then printf(" We are in a cycle !\n"); end if:
         return([evalb(false), pflatFourChain]);
        else
         if verbose then printf("This 4-edge does extend \n"); end if:
        return([true,[pflatFourChain[],oddVertex,newEvenVertex]])
       end if:
      end if:
     end do:
   end if:
  end if:
  # 
  #  IF we are here, then we could not extend the chain.
  #
  return([false, pflatFourChain])

 end proc:
#################################################################################

makeFlatFourChains := proc(Graph)
 #
 #  This finds all long (length six) flat 4-chains in the given graph.
 #    It relies on the structure of graphs from chains of lengths 4.
 #
 global admitTwoEdge, endPoints, Edges:
 local flatFourChains, edge, admitTwo, vertex, pflatFourChain,
         tryAgain, Pair;

 flatFourChains:={}:
 # make sets of 2-, 3-, 4-, and 5- edges
 # make sets of vertices admitting  2-, 3-, 4-, and 5- edges
 Edges[2]:={}: Edges[3]:={}: Edges[4]:={}: Edges[5]:={}:
 endPoints[2]:={}: endPoints[3]:={}: endPoints[4]:={}: endPoints[5]:={}:
 for edge in Graph[2] do
  Edges[edge[1]] := Edges[edge[1]] union {edge}:
  endPoints[edge[1]] := endPoints[edge[1]] union {edge[2],edge[3]}:
 end do:
 #
 #  Step 1:  Find all 4-edges both of whose endpoints admit a 2-edge
 #            admitTwo counts the number of adjacent 2-edges.  We use 
 #            that there are no parallel 2,4-edges.  We also make a smaller
 #            set of vertices that admit 4-edges, for we only want those
 #            4-edges in this new set.
 #
 admitTwoEdge:={}:
 endPoints[4]:={}:
 for edge in Edges[4] do
   admitTwo:=0:
   if ({edge[2],edge[3]} subset endPoints[2] ) then
    admitTwoEdge := admitTwoEdge union {edge}:
    endPoints[4] := endPoints[4] union {edge[2],edge[3]}:
   end if:
 end do:
 if verbose then lprint(admitTwoEdge, endPoints[4]); end if:
 #
 #  Step 2: For each endpoint of each of these edges, try to build a flat 4-chain
 #          pflatFourChain is the possible chain
 #
 for edge in admitTwoEdge do 
  for vertex in {edge[2],edge[3]} do 
   #
   #  Initialize the possible flat 4-chain
   #
   pflatFourChain:=[vertex, op({edge[2],edge[3]} minus {vertex})]:
   if verbose then printf("Here is the nascent flat 4-chain %a\n", pflatFourChain); end if:
   #
   # Now we add to the flat 4-chain.
   #
   tryAgain := evalb(true):
   while tryAgain do 
    Pair:=  lengthen(pflatFourChain):
    tryAgain := Pair[1]:
    pflatFourChain := Pair[2]:
   end do:
   if verbose then printf("Here is the resulting flat 4-chain %a\n\n",pflatFourChain); end if:
   if nops(pflatFourChain) >= 6 then flatFourChains:=flatFourChains union {pflatFourChain}: end if:
  end do:
 end do:
 return(flatFourChains)
end proc:
#################################################################################
