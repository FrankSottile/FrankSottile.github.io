#Laplacian.maple
#
#  There are two vertices in the fundamental domain
#
#   The eight edges are 12,  11+, 21+, 11*
#
#   The pure Schroedinger operator  has two components of critical points:
#    one components x=-1, lambda=1
#    the other one  y=1, lambda=0
#
#####################################################################################################
interface(quiet=true):
with(LinearAlgebra):
with(Groebner):

V:=[u,v]:E:=[a,b,c,d]:
V:=[0,1]:E:=[1,1,1,1]:   # non-isolated critical points  2 components
#V:=[0,1]:E:=[1,2,1,1]:   # non-isolated critical points  1 component
#V:=[0,1]:E:=[1,2,1,3]:   # non-isolated critical points  1 component
####################################################################################################
FloquetMatrix:= Matrix([
  [ V[1] + E[2]*(x+1/x) + E[3]*(y+1/y) , -E[1] -E[4]/x    ],
  [-E[1] - E[4]*x                      ,  V[2] ]]):
####################################################################################################
print(FloquetMatrix);

DR:=numer(CharacteristicPolynomial(FloquetMatrix,lambda)):

#
#  Studying the two components of critical points
#
#G:=Basis([DR, diff(DR,x), diff(DR,y), x*z-1, y*w-1], plex(lambda,w,z,x,y)):factor(G[1]);factor(G[2]);
#Gy:=Basis([DR, diff(DR,x), diff(DR,y), x+1], plex(lambda,x,y));factor(Gy[2]),factor(Gy[3]);
#Gx:=Basis([DR, diff(DR,x), diff(DR,y), y-1], plex(lambda,x,y));factor(Gx[2]),factor(Gx[3]);
#quit;

TA:=Trace(FloquetMatrix);
DA:=Determinant(FloquetMatrix);

#################################################################################
with(plots):
#
#  Make the trigonometric substitution
#
TA := simplify(subs(x=exp(I*theta), y=exp(I*psi), TA)):
DA := simplify(subs(x=exp(I*theta), y=exp(I*psi), DA)):

TA := simplify(TA);
DA := expand(simplify(expand(DA)));

#################################################################################
#
#  The normalization for the drawing
#
L1:=(TA/2 - sqrt(TA^2/4-DA));
L2:=(TA/2 + sqrt(TA^2/4-DA));


CP:=[[0,0],[0,Pi], [Pi,0], [Pi,Pi]]:
CP_values := [seq(evalf(subs(theta=CP[ii][1], psi=CP[ii][2], L1)), ii=1..4),
              seq(evalf(subs(theta=CP[ii][1], psi=CP[ii][2], L2)), ii=1..4)]:
minCP := min(CP_values):
maxCP := max(CP_values):
scale := maxCP-minCP:

maxVal := 6:
minVal := .5:
Range := maxVal-minVal:

####################################################################################################
#
#  We shift the angles theta and rescale the Bloch varieties to fix the drawing
#
tshift := 0:
pshift := 0:
DA := simplify(expand(subs(theta = theta+tshift, psi = psi + pshift, DA)));
TA := simplify(expand(subs(theta = theta+tshift, psi = psi + pshift, TA)));
L1:=(TA/2 - sqrt(TA^2/4-DA)):
L2:=(TA/2 + sqrt(TA^2/4-DA)):

DP1 :=  Range*(L1-minCP)/scale + minVal:
DP2 :=  Range*(L2-minCP)/scale + minVal:

LambdaCritical_x := Range*(-minCP)/scale + minVal:  # y= 1, x = *, psi=pshift
LambdaCritical_y := Range*(1-minCP)/scale + minVal: # x=-1, y = *, theta=Pi+tshift

####################################################################################################
BV1 := proc(r,s)
 local Lst, ii:
 global DP1:
 return(Re(evalf(subs(theta=r, psi=s,DP1))))
end proc:
####################################################################################################
BV2 := proc(r,s)
 local Lst, ii:
 global DP2:
 return(Re(evalf(subs(theta=r, psi=s,DP2))))
end proc:
####################################################################################################

#
TP1:=[theta-tshift, psi-pshift, BV1(theta-tshift,psi-pshift)]:
TP2:=[theta-tshift, psi-pshift, BV2(theta-tshift,psi-pshift)]:

Corner_Points := pointplot3d( [seq(evalf(subs(theta=CP[ii][1],psi=CP[ii][2],TP1)),ii=1..4),
                               seq(evalf(subs(theta=CP[ii][1],psi=CP[ii][2],TP2)),ii=1..4)],color=magenta, symbol=point):
####################################################################################################
#
Npts:=25:  # <---- Needed to hit the Dirac points
npts:=15:
#
#  unfurled torus
Ze  := plot3d( 0, theta=-Pi/2..3/2*Pi, psi=-Pi/2..3/2*Pi,grid=[npts,npts], color=yellow):
#  Frame only
Zf  := plot3d( 0, theta=-Pi/2..3/2*Pi, psi=-Pi/2..3/2*Pi,grid=[npts,npts], style=wireframe, color=black):
#  Edges of the base
Base:=[spacecurve( [ theta, -Pi/2, 0], theta=-Pi/2..3/2*Pi,numpoints=2, color=brown, thickness=3),
       spacecurve( [ theta,3/2*Pi, 0], theta=-Pi/2..3/2*Pi,numpoints=2, color=brown, thickness=3),
       spacecurve( [ -Pi/2,   psi, 0],   psi=-Pi/2..3/2*Pi,numpoints=2, color=brown, thickness=3),
       spacecurve( [3/2*Pi,   psi, 0],   psi=-Pi/2..3/2*Pi,numpoints=2, color=brown, thickness=3)]:
#
#  Two Branches of Bloch Variety
#
La1:=plot3d(BV1, -Pi/2..3/2*Pi, -Pi/2..3/2*Pi,grid=[Npts,Npts]):
La2:=plot3d(BV2, -Pi/2..3/2*Pi, -Pi/2..3/2*Pi,grid=[Npts,Npts]):

#   Possibly masking the lower branch
Ba1:= plot3d( BV1, -Pi/2..3/2*Pi, -Pi/2..0,grid=[Npts,8],style=wireframe,color=black ):
#
#  First make the list of points
#
EDG1 := [ seq([-Pi/2+2*Pi*ii/(Npts-1),  -Pi/2, Re(evalf(subs(  psi= -Pi/2, theta= -Pi/2+2*Pi*ii/(Npts-1),DP1)))],ii=0..Npts-2),
          seq([3/2*Pi, -Pi/2+2*Pi*ii/(Npts-1), Re(evalf(subs(theta=3/2*Pi,   psi= -Pi/2+2*Pi*ii/(Npts-1),DP1)))],ii=0..Npts-2),
          seq([3/2*Pi-2*Pi*ii/(Npts-1),3/2*Pi, Re(evalf(subs(  psi=3/2*Pi, theta=3/2*Pi-2*Pi*ii/(Npts-1),DP1)))],ii=0..Npts-2),
          seq([ -Pi/2,3/2*Pi-2*Pi*ii/(Npts-1), Re(evalf(subs(theta= -Pi/2,   psi=3/2*Pi-2*Pi*ii/(Npts-1),DP1)))],ii=0..Npts-1)]:
EDG2 := [ seq([-Pi/2+2*Pi*ii/(Npts-1),  -Pi/2, Re(evalf(subs(  psi= -Pi/2, theta= -Pi/2+2*Pi*ii/(Npts-1),DP2)))],ii=0..Npts-2),
          seq([3/2*Pi, -Pi/2+2*Pi*ii/(Npts-1), Re(evalf(subs(theta=3/2*Pi,   psi= -Pi/2+2*Pi*ii/(Npts-1),DP2)))],ii=0..Npts-2),
          seq([3/2*Pi-2*Pi*ii/(Npts-1),3/2*Pi, Re(evalf(subs(  psi=3/2*Pi, theta=3/2*Pi-2*Pi*ii/(Npts-1),DP2)))],ii=0..Npts-2),
          seq([ -Pi/2,3/2*Pi-2*Pi*ii/(Npts-1), Re(evalf(subs(theta= -Pi/2,   psi=3/2*Pi-2*Pi*ii/(Npts-1),DP2)))],ii=0..Npts-1)]:
#
#  Edges of two branches
#
Edges1:=spacecurve(EDG1, color=brown, thickness=3):
Edges2:=spacecurve(EDG2, color=brown, thickness=3):
#
#  Make the axes  eps = gap outside of base, as well as 
#
eps:=0.5:
Axes :=[ spacecurve([ 3*Pi/2+eps  , -Pi/2-eps  , t], t=-eps..2*Pi, numpoints=2, color=blue, thickness=4),
         spacecurve([ 3*Pi/2+eps  , -Pi/2-eps+t, 0], t=-eps..2*Pi+3*eps, numpoints=2, color=blue, thickness=4),
         spacecurve([ 3*Pi/2+eps-t, -Pi/2-eps  , 0], t=-eps..2*Pi+3*eps, numpoints=2, color=blue, thickness=4)]:
#
#   [-Pi/2 - 2eps, 3Pi/2 + 2eps] x  [-Pi/2 - 2eps, 3Pi/2 + 2eps] x [-eps, 2Pi]  
#

####################################################################################################
Spectr:= pointplot3d( [seq(evalf([3*Pi/2+eps, -Pi/2-eps,BV1(CP[ii][])]), ii=1..4),
                       seq(evalf([3*Pi/2+eps, -Pi/2-eps,BV2(CP[ii][])]), ii=1..4)], color=red, symbol=point):
#
# These were studied above
#
SingPts:=pointplot3d([[-2*Pi/3,  0,subs(theta=-Pi/3,psi= 2*Pi/3,L1)],
                      [ 2*Pi/3,  0,subs(theta= Pi/3,psi= 2*Pi/3,L1)],
                      [  -Pi/3, Pi,subs(theta=-Pi/3,psi=-2*Pi/3,L1)],
                      [   Pi/3, Pi,subs(theta= Pi/3,psi=-2*Pi/3,L1)]], color=pink, symbol=point):

CritComp1:= spacecurve([ t, pshift, LambdaCritical_x+0.01], t = -Pi/2..3/2*Pi, color=red, thickness=4, numpoints = 2):
CritComp2:= spacecurve([ Pi+tshift, t, LambdaCritical_y+0.01], t = -Pi/2..3/2*Pi, color=red, thickness=4, numpoints = 2):

DR := [
Axes[],
#
Corner_Points,Spectr,
Ze,
#Zf,
Base[],
#Ba1,  # masking
La1,
CritComp1, 
Edges1,
#####################################
#SingPts,
La2,
CritComp2, 
Edges2,
NULL]:

#
Pic:= ang -> display(DR,orientation=[ang,78]):
#Pic:= ang -> display(DR,orientation=[ang,75]):

#display(Pic(210),scaling=constrained);

plotsetup(gif,plotoutput="Laplacian_two_components_movie.gif",plotoptions=`height=1000,width=1000`):
#NFr:=100:
#
NFr:=360:
#animate(Pic,[ang],ang=0..(1-1/NFr)*360,scaling=constrained,axes=none,frames=NFr,paraminfo=false);
#animate(Pic,[ang],ang=246..256,scaling=constrained,axes=none,frames=NFr,paraminfo=true);

#quit;[

plotsetup(gif,plotoutput="A.gif",plotoptions=`height=1000,width=1000`):
#plotsetup(ps,plotoutput=`A.eps`,plotoptions=`color,portrait,width=3in,height=3in,noborder`):
#
display(Pic(240),scaling=constrained);


quit;
NFr:=360:
animate(Pic,[ang],ang=0..(1-1/NFr)*360,scaling=constrained,axes=none,frames=NFr,paraminfo=true);

plotsetup(gif,plotoutput="A.gif",plotoptions=`height=1000,width=1000`):
#plotsetup(ps,plotoutput=`A.eps`,plotoptions=`color,portrait,width=3in,height=3in,noborder`):
#
display(Pic(30),scaling=constrained);

quit;

One good view: [20,75]
Another: [335,73]
