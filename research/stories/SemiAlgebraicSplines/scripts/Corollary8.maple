#Corollary8.maple
#
#  This computes the multiplicity of the scheme S/I, where I is minimally generated by
# t linear forms raised to the power r+1.   This is used in the simplification of 
# Corollary 8
#
#################################################################################
#interface(quiet=true):
#
#  Hilbert function of S = R[x,y,z]
#
HPS := d -> (d+2)*(d+1)/2:
#
#  Let I = ideal L_1^{r+1}, ..., L_t^{r+1}, 
#
#  where L_i is linear in x,y and these powers are linearly independent.
#    (t<=r+2, at least)
#
#  Schenck-Stillman describe the Hilbert-Burch resolution of R[x,y]/I,
#   tensoring with S gives the resolution of S/I.
#
#  S(-r-1-a)^{s_1} \oplus S(-r-2-a)^{s_2}  --> S(-r-1)^t --> S --> S/I
#
# where we have:
#
#  a := \floor (r+1)/(t-1) 
#
# and
#
s1:=(t-1)*a+t-r-2:
s2:=(t-1)-s1:
#
#  Thus the Hilbert function of S/I is
#
Mult := s1*HPS(d-(r+1+a))+s2*HPS(d-(r+2+a)) - t*HPS(d-(r+1)) + HPS(d):
#
#  This has a simple form
#
BNC:= x -> x*(x-1)/2;
#
BNC(a+r+2) - t*BNC(a+1);
#
expand(BNC(a+r+2) - t*BNC(a+1)-Mult);
#
#  Now let us compute the Hilbert function
#
HFS:= d ->  piecewise(d<0, 0, d>=0, HPS(d)):
#
#  This is for t=3.
#
interface(quiet=true):
printf("  r |  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n");
printf(" ---+------------------------------------------------------------------------------------\n");
T:=3:
for r from 1 to 15 do 
 printf("%3d |",r);
 t := min(T,r+1):
 a := floor((r+1)/(t-1)):
 s1:=(t-1)*a+t-r-2:
 s2:=(t-1)-s1:
 HF := d -> printf("%3d ",s1*HFS(d-(r+1+a))+s2*HFS(d-(r+2+a)) - t*HFS(d-(r+1)) + HFS(d)):
 seq(HF(d), d=0..20);
 printf("\n");
end do:
printf(" ---+------------------------------------------------------------------------------------\n");
printf("  r |  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n");

