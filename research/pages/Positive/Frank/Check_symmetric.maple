#Check_symmetric.maple
#
#     This Maple script decomposes the quasi-symmetric generating functions of dual
# equivalence graphs into symmetric functions.  It does this by manipulating vectors
# representing their quasi-symmetric generating functions.  It also checks that each
# dual equivalence graph is both symmetric and Schur-positive.
#
#   It requires the file symmetric/s.n for n=2..6
#
#   Its output 
#
#
# Connected graphs of words of length n are stored in the files
# Graphs.n/g.k, where g.k contains all connected graphs with k vertices.
#
################################################################################
interface(quiet=true):
read("procedures.maple"):
################################################################################
#
# symmetric/s.n contains  the symmetric functions.
#
######################################################
with(LinearAlgebra):
n:=6:
#
#  sizes[n] are the sizes of the dual equivalence graphs
#   below each is the number of isomorphism classes.
#
sizes[2]:=[1]:
#          2 
sizes[3]:=[1,2]:
#          2 1
sizes[4]:=[1,2,3,5]:
#          2 1 2 2
sizes[5]:=[1,4,5,6,9,11,16,20]:
#          2 2 2 1 6  8  4  2
sizes[6]:= {1,5,9,10,14,16,19,21,26,35,37,40,42,45,47,54,56,59,61,66,75,80,91,96}:
#           2 4 2  2 12  1 22  8 24 
#
statsFile:=sprintf("statistics.%d",n):
#
#  Reads a pre-computed list of Schur functions
#
read( sprintf("symmetric/s.%d",n) ):

allDescents := combinat[powerset]([seq(ii,ii=1..n-1)]):
Partitions := []:

###########################################################
#
# Initialize the list of partitions, as well as the hash table
#  which stores the Schur function as a vector recording its
#  quasi-symmetric function components.
#
for schurFunction in schurFunctions do

 Partitions := [ Partitions[], schurFunction[1] ]:
 schur[schurFunction[1]] := makeVector(schurFunction[2]):

end do:
###########################################################
#
#  Ansatz is the generic sum of Schur functions with variable coefficients.
#
Ansatz:= Vector[row](2^(n-1), 0):
variables:={}:
Vlist:=[]:
for lambda in Partitions do
 Ansatz := VectorAdd(Ansatz, schur[lambda], 1, c[lambda]):
 variables := variables union {c[lambda]}:
 Vlist:=[Vlist[],c[lambda]]:
end do:
#
#   We keep track of all Schur functions of dual equivalent graphs that are found.
#
Functions:={}:
#
# The for...do loops below check each graph first for being symetric, and then 
#   for Schur-positivity.   They implicitly assume that there is a unique
#   linear combination of Schur functions that equals the quasi-symmetric
#   function of each dual equivalence graph.  (This assumption holds up to n=6)
#
for k in sizes[n] do 
 #
 #  Read set G of graphs on n letters with k vertices
 #
 read(sprintf("Graphs.%d/g.%d",n,k)):
 #
 file:=fopen(statsFile,APPEND):
 fprintf(file,"Testing Graphs.%d/g.%d \n",n,k):
 fclose(file):
 #
 #  Loop over all graphs in Graphs.n/g.k
 #
 for Gr in G do
  DescentFreq := makeDesSeq(Gr)[2]:
  V := makeVector(makeDesSeq(Gr)[2]):
  S:=  solve({seq(V[ii]=Ansatz[ii], ii=1..2^(n-1))});
  if S={} then 
    file:=fopen(statsFile,APPEND):
    printf(file," !!!!! Not symmetric:  %a\n", makeDesSeq(Gr)[2]):
    fclose(file):
    pos:=false:
   else
    values:=subs(op(S),variables);
    pos := true:
    for numbs in values do
     pos := pos and evalb(numbs>=0):
    end do:
    #
    Functions := Functions union {[k, subs(op(S),Vlist)]}:
    #
  end if:
  if not pos then 
   file:=fopen(statsFile,APPEND):
   fprintf(file,"!!!! Not Schur Positive: %a\n", Gr):
    fclose(file):
  end if:
 end do:
 #
end do:	
#
#  Record the symmetric functions found for the dual equivalence graphs
#
file:=fopen(statsFile,APPEND):
fprintf(file,"###### Symmetric functions for graphs from chains of length %d. ######\n",n):
fprintf(file,"Paritions\n",n):
fprintf(file,"%a\n",Vlist):
fprintf(file,"The lists in the folowing lines record the symmetric functions of the dual\n"):
fprintf(file," equivalence graphs.  They are pairs [i, coeffs], where i is the number of\n"):
fprintf(file," vertices in a graph and coeffs is the vector of Schur coefficients, where the\n"):
fprintf(file," order is the order of the partitions just given.\n"):
for V in Functions do
 fprintf(file," %a\n",V):
end do:
fprintf(file,"This computation took %4.2f seconds.\n",time()):
fprintf(file,"########################################################\n"):

quit;
###############################################
